"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-history";
exports.ids = ["vendor-chunks/slate-history"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-history/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/slate-history/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HISTORY: () => (/* binding */ HISTORY),\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   HistoryEditor: () => (/* binding */ HistoryEditor),\n/* harmony export */   MERGING: () => (/* binding */ MERGING),\n/* harmony export */   SAVING: () => (/* binding */ SAVING),\n/* harmony export */   SPLITTING_ONCE: () => (/* binding */ SPLITTING_ONCE),\n/* harmony export */   withHistory: () => (/* binding */ withHistory)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\n\n// eslint-disable-next-line no-redeclare\nvar History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n  isHistory(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || slate__WEBPACK_IMPORTED_MODULE_1__.Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || slate__WEBPACK_IMPORTED_MODULE_1__.Operation.isOperationList(value.undos[0].operations));\n  }\n};\n\n/**\n * Weakmaps for attaching state to the editor.\n */\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar SPLITTING_ONCE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(value);\n  },\n  /**\n   * Get the merge flag's current value.\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\n   * Get the splitting once flag's current value.\n   */\n  isSplittingOnce(editor) {\n    return SPLITTING_ONCE.get(editor);\n  },\n  setSplittingOnce(editor, value) {\n    SPLITTING_ONCE.set(editor, value);\n  },\n  /**\n   * Get the saving flag's current value.\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\n   * Redo to the previous saved state.\n   */\n  redo(editor) {\n    editor.redo();\n  },\n  /**\n   * Undo to the previous saved state.\n   */\n  undo(editor) {\n    editor.undo();\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE.delete(editor);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    try {\n      fn();\n    } finally {\n      SAVING.set(editor, prev);\n    }\n  }\n};\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      if (batch.selectionBefore) {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.setSelection(e, batch.selectionBefore);\n      }\n      HistoryEditor.withoutSaving(e, () => {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Editor.withoutNormalizing(e, () => {\n          for (var op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.operations.map(slate__WEBPACK_IMPORTED_MODULE_1__.Operation.inverse).reverse();\n          for (var op of inverseOps) {\n            e.apply(op);\n          }\n          if (batch.selectionBefore) {\n            slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false;\n        HistoryEditor.setSplittingOnce(e, undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        e.writeHistory('undos', batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      history.redos = [];\n    }\n    apply(op);\n  };\n  e.writeHistory = (stack, batch) => {\n    e.history[stack].push(batch);\n  };\n  return e;\n};\n/**\n * Check whether to merge an operation into the previous operation.\n */\nvar shouldMerge = (op, prev) => {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\n/**\n * Check whether an operation needs to be saved to the history.\n */\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n  return true;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtaGlzdG9yeS9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNZOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFhLG9HQUFvRyw0Q0FBUyw2RUFBNkUsNENBQVM7QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5Q0FBTTtBQUNyRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBVTtBQUNsQjtBQUNBO0FBQ0EsUUFBUSx5Q0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFNO0FBQ2QsZ0RBQWdELDRDQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBVTtBQUN0QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILHVDQUFJO0FBQzlIO0FBQ0E7QUFDQSx3SEFBd0gsdUNBQUk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlGO0FBQ3pGIiwic291cmNlcyI6WyJEOlxccGV0cm9sZWFyblxccGV0cm9sZWFybnNcXG5vZGVfbW9kdWxlc1xcc2xhdGUtaGlzdG9yeVxcZGlzdFxcaW5kZXguZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgeyBPcGVyYXRpb24sIEVkaXRvciwgVHJhbnNmb3JtcywgUGF0aCB9IGZyb20gJ3NsYXRlJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEhpc3RvcnkgPSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYEhpc3RvcnlgIG9iamVjdC5cbiAgICovXG4gIGlzSGlzdG9yeSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnJlZG9zKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnVuZG9zKSAmJiAodmFsdWUucmVkb3MubGVuZ3RoID09PSAwIHx8IE9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUucmVkb3NbMF0ub3BlcmF0aW9ucykpICYmICh2YWx1ZS51bmRvcy5sZW5ndGggPT09IDAgfHwgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS51bmRvc1swXS5vcGVyYXRpb25zKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2Vha21hcHMgZm9yIGF0dGFjaGluZyBzdGF0ZSB0byB0aGUgZWRpdG9yLlxuICovXG52YXIgSElTVE9SWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgU0FWSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBNRVJHSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBTUExJVFRJTkdfT05DRSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgSGlzdG9yeUVkaXRvciA9IHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgSGlzdG9yeUVkaXRvcmAgb2JqZWN0LlxuICAgKi9cbiAgaXNIaXN0b3J5RWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhpc3RvcnkuaXNIaXN0b3J5KHZhbHVlLmhpc3RvcnkpICYmIEVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1lcmdlIGZsYWcncyBjdXJyZW50IHZhbHVlLlxuICAgKi9cbiAgaXNNZXJnaW5nKGVkaXRvcikge1xuICAgIHJldHVybiBNRVJHSU5HLmdldChlZGl0b3IpO1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBzcGxpdHRpbmcgb25jZSBmbGFnJ3MgY3VycmVudCB2YWx1ZS5cbiAgICovXG4gIGlzU3BsaXR0aW5nT25jZShlZGl0b3IpIHtcbiAgICByZXR1cm4gU1BMSVRUSU5HX09OQ0UuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIHNldFNwbGl0dGluZ09uY2UoZWRpdG9yLCB2YWx1ZSkge1xuICAgIFNQTElUVElOR19PTkNFLnNldChlZGl0b3IsIHZhbHVlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgc2F2aW5nIGZsYWcncyBjdXJyZW50IHZhbHVlLlxuICAgKi9cbiAgaXNTYXZpbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIFNBVklORy5nZXQoZWRpdG9yKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJlZG8gdG8gdGhlIHByZXZpb3VzIHNhdmVkIHN0YXRlLlxuICAgKi9cbiAgcmVkbyhlZGl0b3IpIHtcbiAgICBlZGl0b3IucmVkbygpO1xuICB9LFxuICAvKipcbiAgICogVW5kbyB0byB0aGUgcHJldmlvdXMgc2F2ZWQgc3RhdGUuXG4gICAqL1xuICB1bmRvKGVkaXRvcikge1xuICAgIGVkaXRvci51bmRvKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIFRoZXNlIG9wZXJhdGlvbnMgd2lsbFxuICAgKiBiZSBtZXJnZWQgaW50byB0aGUgcHJldmlvdXMgaGlzdG9yeS5cbiAgICovXG4gIHdpdGhNZXJnaW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgcHJldiA9IEhpc3RvcnlFZGl0b3IuaXNNZXJnaW5nKGVkaXRvcik7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBmbigpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgcHJldik7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0XG4gICAqIG9wZXJhdGlvbiBzdGFydHMgYSBuZXcgYmF0Y2ggaW4gdGhlIGhpc3RvcnkuIFN1YnNlcXVlbnQgb3BlcmF0aW9ucyB3aWxsIGJlXG4gICAqIG1lcmdlZCBhcyB1c3VhbC5cbiAgICovXG4gIHdpdGhOZXdCYXRjaChlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHByZXYgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlZGl0b3IpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgU1BMSVRUSU5HX09OQ0Uuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgZm4oKTtcbiAgICBNRVJHSU5HLnNldChlZGl0b3IsIHByZXYpO1xuICAgIFNQTElUVElOR19PTkNFLmRlbGV0ZShlZGl0b3IpO1xuICB9LFxuICAvKipcbiAgICogQXBwbHkgYSBzZXJpZXMgb2YgY2hhbmdlcyBpbnNpZGUgYSBzeW5jaHJvbm91cyBgZm5gLCB3aXRob3V0IG1lcmdpbmcgYW55IG9mXG4gICAqIHRoZSBuZXcgb3BlcmF0aW9ucyBpbnRvIHByZXZpb3VzIHNhdmUgcG9pbnQgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICB3aXRob3V0TWVyZ2luZyhlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHByZXYgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlZGl0b3IpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGZuKCk7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgfSxcbiAgLyoqXG4gICAqIEFwcGx5IGEgc2VyaWVzIG9mIGNoYW5nZXMgaW5zaWRlIGEgc3luY2hyb25vdXMgYGZuYCwgd2l0aG91dCBzYXZpbmcgYW55IG9mXG4gICAqIHRoZWlyIG9wZXJhdGlvbnMgaW50byB0aGUgaGlzdG9yeS5cbiAgICovXG4gIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciBwcmV2ID0gSGlzdG9yeUVkaXRvci5pc1NhdmluZyhlZGl0b3IpO1xuICAgIFNBVklORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGB3aXRoSGlzdG9yeWAgcGx1Z2luIGtlZXBzIHRyYWNrIG9mIHRoZSBvcGVyYXRpb24gaGlzdG9yeSBvZiBhIFNsYXRlXG4gKiBlZGl0b3IgYXMgb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byBpdCwgdXNpbmcgdW5kbyBhbmQgcmVkbyBzdGFja3MuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcbiAqIHRoaXMgcGx1Z2luLlxuICpcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXG4gKi9cbnZhciB3aXRoSGlzdG9yeSA9IGVkaXRvciA9PiB7XG4gIHZhciBlID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGFwcGx5XG4gIH0gPSBlO1xuICBlLmhpc3RvcnkgPSB7XG4gICAgdW5kb3M6IFtdLFxuICAgIHJlZG9zOiBbXVxuICB9O1xuICBlLnJlZG8gPSAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGhpc3RvcnlcbiAgICB9ID0gZTtcbiAgICB2YXIge1xuICAgICAgcmVkb3NcbiAgICB9ID0gaGlzdG9yeTtcbiAgICBpZiAocmVkb3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJhdGNoID0gcmVkb3NbcmVkb3MubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYmF0Y2guc2VsZWN0aW9uQmVmb3JlKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGUsIGJhdGNoLnNlbGVjdGlvbkJlZm9yZSk7XG4gICAgICB9XG4gICAgICBIaXN0b3J5RWRpdG9yLndpdGhvdXRTYXZpbmcoZSwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGUsICgpID0+IHtcbiAgICAgICAgICBmb3IgKHZhciBvcCBvZiBiYXRjaC5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBlLmFwcGx5KG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBoaXN0b3J5LnJlZG9zLnBvcCgpO1xuICAgICAgZS53cml0ZUhpc3RvcnkoJ3VuZG9zJywgYmF0Y2gpO1xuICAgIH1cbiAgfTtcbiAgZS51bmRvID0gKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoaXN0b3J5XG4gICAgfSA9IGU7XG4gICAgdmFyIHtcbiAgICAgIHVuZG9zXG4gICAgfSA9IGhpc3Rvcnk7XG4gICAgaWYgKHVuZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBiYXRjaCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdO1xuICAgICAgSGlzdG9yeUVkaXRvci53aXRob3V0U2F2aW5nKGUsICgpID0+IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlLCAoKSA9PiB7XG4gICAgICAgICAgdmFyIGludmVyc2VPcHMgPSBiYXRjaC5vcGVyYXRpb25zLm1hcChPcGVyYXRpb24uaW52ZXJzZSkucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAodmFyIG9wIG9mIGludmVyc2VPcHMpIHtcbiAgICAgICAgICAgIGUuYXBwbHkob3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmF0Y2guc2VsZWN0aW9uQmVmb3JlKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlLCBiYXRjaC5zZWxlY3Rpb25CZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGUud3JpdGVIaXN0b3J5KCdyZWRvcycsIGJhdGNoKTtcbiAgICAgIGhpc3RvcnkudW5kb3MucG9wKCk7XG4gICAgfVxuICB9O1xuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciB7XG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgaGlzdG9yeVxuICAgIH0gPSBlO1xuICAgIHZhciB7XG4gICAgICB1bmRvc1xuICAgIH0gPSBoaXN0b3J5O1xuICAgIHZhciBsYXN0QmF0Y2ggPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdE9wID0gbGFzdEJhdGNoICYmIGxhc3RCYXRjaC5vcGVyYXRpb25zW2xhc3RCYXRjaC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzYXZlID0gSGlzdG9yeUVkaXRvci5pc1NhdmluZyhlKTtcbiAgICB2YXIgbWVyZ2UgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlKTtcbiAgICBpZiAoc2F2ZSA9PSBudWxsKSB7XG4gICAgICBzYXZlID0gc2hvdWxkU2F2ZShvcCk7XG4gICAgfVxuICAgIGlmIChzYXZlKSB7XG4gICAgICBpZiAobWVyZ2UgPT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEJhdGNoID09IG51bGwpIHtcbiAgICAgICAgICBtZXJnZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgbWVyZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlID0gc2hvdWxkTWVyZ2Uob3AsIGxhc3RPcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChIaXN0b3J5RWRpdG9yLmlzU3BsaXR0aW5nT25jZShlKSkge1xuICAgICAgICBtZXJnZSA9IGZhbHNlO1xuICAgICAgICBIaXN0b3J5RWRpdG9yLnNldFNwbGl0dGluZ09uY2UoZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0QmF0Y2ggJiYgbWVyZ2UpIHtcbiAgICAgICAgbGFzdEJhdGNoLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmF0Y2ggPSB7XG4gICAgICAgICAgb3BlcmF0aW9uczogW29wXSxcbiAgICAgICAgICBzZWxlY3Rpb25CZWZvcmU6IGUuc2VsZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGUud3JpdGVIaXN0b3J5KCd1bmRvcycsIGJhdGNoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh1bmRvcy5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgdW5kb3Muc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGhpc3RvcnkucmVkb3MgPSBbXTtcbiAgICB9XG4gICAgYXBwbHkob3ApO1xuICB9O1xuICBlLndyaXRlSGlzdG9yeSA9IChzdGFjaywgYmF0Y2gpID0+IHtcbiAgICBlLmhpc3Rvcnlbc3RhY2tdLnB1c2goYmF0Y2gpO1xuICB9O1xuICByZXR1cm4gZTtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdG8gbWVyZ2UgYW4gb3BlcmF0aW9uIGludG8gdGhlIHByZXZpb3VzIG9wZXJhdGlvbi5cbiAqL1xudmFyIHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiB7XG4gIGlmIChwcmV2ICYmIG9wLnR5cGUgPT09ICdpbnNlcnRfdGV4dCcgJiYgcHJldi50eXBlID09PSAnaW5zZXJ0X3RleHQnICYmIG9wLm9mZnNldCA9PT0gcHJldi5vZmZzZXQgKyBwcmV2LnRleHQubGVuZ3RoICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocHJldiAmJiBvcC50eXBlID09PSAncmVtb3ZlX3RleHQnICYmIHByZXYudHlwZSA9PT0gJ3JlbW92ZV90ZXh0JyAmJiBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gcHJldi5vZmZzZXQgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcHJldi5wYXRoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb3BlcmF0aW9uIG5lZWRzIHRvIGJlIHNhdmVkIHRvIHRoZSBoaXN0b3J5LlxuICovXG52YXIgc2hvdWxkU2F2ZSA9IChvcCwgcHJldikgPT4ge1xuICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgSElTVE9SWSwgSGlzdG9yeSwgSGlzdG9yeUVkaXRvciwgTUVSR0lORywgU0FWSU5HLCBTUExJVFRJTkdfT05DRSwgd2l0aEhpc3RvcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-history/dist/index.es.js\n");

/***/ })

};
;